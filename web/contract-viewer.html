<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contract Analyzer</title>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--bg-page);
            color: var(--text-primary);
            line-height: 1.5;
        }
        h1 {
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
        .subtitle {
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }
        .input-section {
            margin-bottom: 2rem;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 1rem;
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 14px;
            border: 1px solid var(--border-default);
            border-radius: 6px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-alpha-10);
        }
        .button-row {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
        }
        button {
            padding: 0.6rem 1.2rem;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        button.primary {
            background: var(--primary);
            color: white;
        }
        button.primary:hover {
            background: var(--primary-dark);
        }
        button.secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-default);
        }
        button.secondary:hover {
            background: var(--bg-hover);
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .results-section {
            margin-top: 2rem;
        }
        .text-display {
            background: var(--bg-card);
            border: 1px solid var(--border-default);
            border-left: 4px solid var(--primary);
            border-radius: 0 6px 6px 0;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        .text-display h3 {
            margin: 0 0 0.5rem 0;
            font-size: 14px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .text-content {
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .tracks-display {
            background: var(--bg-card);
            border: 1px solid var(--border-default);
            border-left: 4px solid var(--primary);
            border-radius: 0 6px 6px 0;
            padding: 1rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }
        .tracks-display h3 {
            margin: 0 0 0.5rem 0;
            font-size: 14px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .tracks-content {
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 13px;
            white-space: pre;
            line-height: 1.4;
        }
        .track-line {
            color: var(--primary);
        }
        .track-label {
            color: var(--accent-purple);
            font-weight: 500;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-card);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-default);
        }
        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-subtle);
        }
        th {
            background: var(--bg-secondary);
            font-weight: 600;
            font-size: 13px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        td {
            font-size: 14px;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr:hover td {
            background: var(--bg-hover);
        }
        .kind-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            color: #000;
        }
        .layer-filters {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--bg-card);
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            font-size: 13px;
            padding: 1rem;
            border: 1px solid var(--border-default);
            border-radius: 6px;
            margin-bottom: 1rem;
        }
        .layer-filters label {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            cursor: pointer;
        }
        .snippet {
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 13px;
            background: var(--bg-secondary);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }
        .offsets {
            color: var(--text-secondary);
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 12px;
        }
        .metadata {
            font-size: 12px;
            color: var(--text-secondary);
        }
        .test-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-default);
        }
        .test-log {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            border-radius: 6px;
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .test-pass {
            color: var(--success);
        }
        .test-fail {
            color: var(--error);
        }
        .test-info {
            color: var(--info);
        }
        .empty-state {
            color: var(--text-secondary);
            font-style: italic;
            padding: 2rem;
            text-align: center;
        }
        .error-message {
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            color: var(--error);
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }
        .version-info {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <h1>Contract Analyzer</h1>
    <p class="subtitle">Analyze contract text using layered-nlp WASM module</p>

    <div class="input-section">
        <textarea id="contract-input">SERVICES AGREEMENT

"Company" means ABC Corporation (the "ABC"). "Contractor" means XYZ Services LLC (the "Provider").

The Contractor shall provide consulting services to the Company. The Company shall pay the Contractor within 30 days of invoice receipt. We agree to the terms herein.

However, the Company may terminate this agreement if Contractor fails to perform. It shall provide 30 days written notice. Therefore, timely performance is essential.

I, the undersigned, represent that the information provided here is accurate. You shall notify us of any changes.

Unless otherwise agreed, the Contractor shall maintain confidentiality. Subject to applicable law, the Provider shall indemnify the Company.</textarea>
        <div class="button-row">
            <button id="analyze-btn" class="primary">Analyze</button>
            <button id="clear-btn" class="secondary">Clear</button>
        </div>
        <div class="layer-filters" id="layer-filters" style="display: none;">
            <!-- Filters will be generated dynamically from resolver manifests -->
        </div>
    </div>

    <div id="error-container"></div>

    <div id="results-section" class="results-section" style="display: none;">
        <div class="text-display">
            <h3>Analyzed Text</h3>
            <div id="text-content" class="text-content"></div>
            <div id="version-info" class="version-info"></div>
        </div>

        <div class="tracks-display">
            <h3>Span Tracks</h3>
            <div id="tracks-content" class="tracks-content"></div>
        </div>

        <h3 style="margin-bottom: 0.5rem;">Detected Spans</h3>
        <table id="spans-table">
            <thead>
                <tr>
                    <th>Kind</th>
                    <th>Label</th>
                    <th>Offsets</th>
                    <th>Snippet</th>
                    <th>Metadata</th>
                </tr>
            </thead>
            <tbody id="spans-tbody"></tbody>
        </table>
    </div>

    <div class="test-section">
        <button id="run-tests-btn" class="secondary">Run Tests</button>
        <div id="test-log" class="test-log" style="display: none;"></div>
    </div>

    <script type="module">
        let wasmModule = null;
        let lastAnalysisResult = null;
        let resolverManifests = null;

        function getVisibleKinds() {
            const checkboxes = document.querySelectorAll('#layer-filters input[type="checkbox"]');
            return Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.kind);
        }

        function filterSpans(spans) {
            const visibleKinds = getVisibleKinds();
            return spans.filter(s => visibleKinds.includes(s.kind));
        }

        function generateLayerFilters(manifests) {
            const filterDiv = document.getElementById('layer-filters');
            filterDiv.innerHTML = '';

            // Add heading
            const heading = document.createElement('strong');
            heading.style.fontSize = '13px';
            heading.style.color = 'var(--text-secondary)';
            heading.textContent = 'Show layers:';
            filterDiv.appendChild(heading);

            for (const manifest of manifests) {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.setAttribute('data-kind', manifest.name);
                // Stable checked by default, Experimental unchecked
                input.checked = manifest.tags.includes('stable');
                input.addEventListener('change', renderResults);

                let text = manifest.name;
                if (manifest.tags.includes('experimental')) {
                    text = '⚠️ ' + text;
                }

                label.appendChild(input);
                label.appendChild(document.createTextNode(' ' + text));
                filterDiv.appendChild(label);
            }

            // Add keyboard shortcut hint
            const hint = document.createElement('span');
            hint.style.marginLeft = 'auto';
            hint.style.fontSize = '12px';
            hint.style.color = 'var(--text-tertiary)';
            hint.textContent = 'Keyboard: Ctrl/Cmd+Enter to analyze';
            filterDiv.appendChild(hint);
        }

        function loadResolverManifests() {
            if (!wasmModule) return;
            try {
                resolverManifests = wasmModule.get_resolver_manifests();
                if (resolverManifests && resolverManifests.length > 0) {
                    generateLayerFilters(resolverManifests);
                } else {
                    console.warn('No resolver manifests available');
                }
            } catch (err) {
                console.error('Failed to load resolver manifests:', err);
            }
        }

        async function loadWasm() {
            try {
                const module = await import('./pkg/layered_nlp_demo_wasm.js');
                await module.default();
                wasmModule = module;
                console.log('WASM module loaded');
                loadResolverManifests();
                return true;
            } catch (err) {
                console.error('Failed to load WASM:', err);
                showError(`Failed to load WASM module: ${err.message}. Make sure the WASM files are in ./pkg/`);
                return false;
            }
        }

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error-message">${escapeHtml(message)}</div>`;
        }

        function clearError() {
            document.getElementById('error-container').innerHTML = '';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function analyzeContract(text) {
            if (!wasmModule) {
                throw new Error('WASM module not loaded');
            }
            return wasmModule.analyze_contract(text);
        }

        function assignLanes(spans) {
            const sortedSpans = [...spans].sort((a, b) => {
                const aStart = a.start_offset ?? a.start;
                const bStart = b.start_offset ?? b.start;
                const aEnd = a.end_offset ?? a.end;
                const bEnd = b.end_offset ?? b.end;
                if (aStart !== bStart) return aStart - bStart;
                return bEnd - aEnd;
            });

            const lanes = [];
            const spanLanes = new Map();

            for (const span of sortedSpans) {
                const start = span.start_offset ?? span.start;
                const end = span.end_offset ?? span.end;
                let assignedLane = -1;
                for (let i = 0; i < lanes.length; i++) {
                    const laneEnd = lanes[i];
                    if (start >= laneEnd) {
                        assignedLane = i;
                        lanes[i] = end;
                        break;
                    }
                }
                if (assignedLane === -1) {
                    assignedLane = lanes.length;
                    lanes.push(end);
                }
                spanLanes.set(span, assignedLane);
            }

            return { sortedSpans, spanLanes, laneCount: lanes.length };
        }

        function renderTracks(text, spans) {
            if (spans.length === 0) {
                return '<span class="empty-state">No spans detected</span>';
            }

            const { sortedSpans, spanLanes, laneCount } = assignLanes(spans);

            const lines = text.split('\n');
            let output = [];
            let lineOffset = 0;

            for (const line of lines) {
                const lineStart = lineOffset;
                const lineEnd = lineOffset + line.length;
                
                output.push(escapeHtml(line));

                const lineSpans = sortedSpans.filter(s => {
                    const start = s.start_offset ?? s.start;
                    const end = s.end_offset ?? s.end;
                    return start < lineEnd && end > lineStart;
                });

                const laneLines = [];
                for (let lane = 0; lane < laneCount; lane++) {
                    const laneSpans = lineSpans.filter(s => spanLanes.get(s) === lane);
                    if (laneSpans.length === 0) continue;

                    let trackLine = ' '.repeat(line.length);
                    let labels = [];

                    for (const span of laneSpans) {
                        const spanStart = span.start_offset ?? span.start;
                        const spanEnd = span.end_offset ?? span.end;
                        const relStart = Math.max(0, spanStart - lineStart);
                        const relEnd = Math.min(line.length, spanEnd - lineStart);
                        
                        if (relStart >= relEnd) continue;

                        const chars = trackLine.split('');
                        
                        if (relEnd - relStart === 1) {
                            chars[relStart] = '╵';
                        } else {
                            chars[relStart] = '╰';
                            for (let i = relStart + 1; i < relEnd - 1; i++) {
                                chars[i] = '─';
                            }
                            chars[relEnd - 1] = '╯';
                        }
                        trackLine = chars.join('');

                        const label = span.label || span.kind;
                        labels.push({ pos: relEnd, label });
                    }

                    let trackWithLabels = `<span class="track-line">${escapeHtml(trackLine)}</span>`;
                    if (labels.length > 0) {
                        const labelStr = labels.map(l => l.label).join(', ');
                        trackWithLabels += `<span class="track-label">${escapeHtml(labelStr)}</span>`;
                    }
                    laneLines.push(trackWithLabels);
                }

                output.push(...laneLines);
                lineOffset = lineEnd + 1;
            }

            return output.join('\n');
        }

        function renderSpansTable(spans) {
            const tbody = document.getElementById('spans-tbody');

            if (spans.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="empty-state">No spans detected</td></tr>';
                return;
            }

            tbody.innerHTML = spans.map(span => {
                const start = span.start_offset ?? span.start;
                const end = span.end_offset ?? span.end;
                // Handle both Map (from serde-wasm-bindgen) and plain objects
                let metadata = '';
                if (span.metadata) {
                    if (span.metadata instanceof Map) {
                        metadata = JSON.stringify(Object.fromEntries(span.metadata));
                    } else {
                        metadata = JSON.stringify(span.metadata);
                    }
                }
                // Use span.color for dynamic badge styling
                const bgColor = span.color || '#ccc';
                // Add experimental warning if tagged
                const isExperimental = span.tags && span.tags.includes('experimental');
                const experimentalSuffix = isExperimental ? ' ⚠️' : '';
                return `
                    <tr>
                        <td><span class="kind-badge" style="background-color: ${escapeHtml(bgColor)}">${escapeHtml(span.kind)}${experimentalSuffix}</span></td>
                        <td>${escapeHtml(span.label || '')}</td>
                        <td class="offsets">${start}..${end}</td>
                        <td><code class="snippet">${escapeHtml(span.snippet || '')}</code></td>
                        <td class="metadata">${escapeHtml(metadata)}</td>
                    </tr>
                `;
            }).join('');
        }

        async function handleAnalyze() {
            clearError();
            const text = document.getElementById('contract-input').value;
            
            if (!wasmModule) {
                const loaded = await loadWasm();
                if (!loaded) return;
            }

            try {
                const result = analyzeContract(text);
                
                // Add snippet to each span
                const spansWithSnippets = result.spans.map(s => ({
                    ...s,
                    start: s.start_offset,
                    end: s.end_offset,
                    snippet: result.text.slice(s.start_offset, s.end_offset)
                }));
                
                lastAnalysisResult = { ...result, spans: spansWithSnippets };
                
                document.getElementById('layer-filters').style.display = 'flex';
                document.getElementById('results-section').style.display = 'block';
                document.getElementById('text-content').textContent = result.text;
                document.getElementById('version-info').textContent = `Version: ${result.version || 'unknown'}`;
                
                renderResults();
            } catch (err) {
                showError(`Analysis failed: ${err.message}`);
            }
        }

        function handleClear() {
            document.getElementById('contract-input').value = '';
            document.getElementById('results-section').style.display = 'none';
            document.getElementById('layer-filters').style.display = 'none';
            lastAnalysisResult = null;
            clearError();
        }

        function renderResults() {
            if (!lastAnalysisResult) return;
            const filteredSpans = filterSpans(lastAnalysisResult.spans);
            document.getElementById('tracks-content').innerHTML = renderTracks(lastAnalysisResult.text, filteredSpans);
            renderSpansTable(filteredSpans);
        }

        // Test framework
        class TestRunner {
            constructor() {
                this.log = [];
                this.passed = 0;
                this.failed = 0;
            }

            logInfo(msg) {
                this.log.push(`<span class="test-info">[INFO]</span> ${escapeHtml(msg)}`);
            }

            logPass(name) {
                this.passed++;
                this.log.push(`<span class="test-pass">[PASS]</span> ${escapeHtml(name)}`);
            }

            logFail(name, reason) {
                this.failed++;
                this.log.push(`<span class="test-fail">[FAIL]</span> ${escapeHtml(name)}: ${escapeHtml(reason)}`);
            }

            assert(condition, name, failReason) {
                if (condition) {
                    this.logPass(name);
                } else {
                    this.logFail(name, failReason);
                }
            }

            getOutput() {
                const summary = `\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nResults: ${this.passed} passed, ${this.failed} failed`;
                return this.log.join('\n') + summary;
            }
        }

        async function runTests() {
            const logEl = document.getElementById('test-log');
            logEl.style.display = 'block';
            logEl.innerHTML = 'Loading WASM module...';

            if (!wasmModule) {
                const loaded = await loadWasm();
                if (!loaded) {
                    logEl.innerHTML = '<span class="test-fail">Failed to load WASM module</span>';
                    return;
                }
            }

            const runner = new TestRunner();
            runner.logInfo('Starting test suite...\n');

            // Test 1: Empty text (expected to throw - create_line_from_string panics on empty)
            try {
                runner.logInfo('test_empty_text');
                const result = analyzeContract('');
                // If we get here without error, check for empty spans
                runner.assert(
                    Array.isArray(result.spans) && result.spans.length === 0,
                    'test_empty_text',
                    `Expected empty spans array, got ${JSON.stringify(result.spans)}`
                );
            } catch (err) {
                // Expected: create_line_from_string panics on empty string
                runner.logPass('test_empty_text (throws on empty input as expected)');
            }

            // Test 2: Simple keyword detection
            try {
                runner.logInfo('test_simple_keyword');
                const result = analyzeContract('The party shall pay.');
                const hasKeyword = result.spans.some(s => 
                    s.kind === 'ContractKeyword' || s.kind === 'Keyword'
                );
                runner.assert(
                    hasKeyword,
                    'test_simple_keyword',
                    `Expected ContractKeyword span, got: ${JSON.stringify(result.spans)}`
                );
            } catch (err) {
                runner.logFail('test_simple_keyword', err.message);
            }

            // Test 3: Defined term detection
            try {
                runner.logInfo('test_defined_term');
                const result = analyzeContract('"Company" means ABC Corp');
                const hasDefinedTerm = result.spans.some(s =>
                    s.kind === 'DefinedTerm' || s.kind === 'Definition'
                );
                runner.assert(
                    hasDefinedTerm,
                    'test_defined_term',
                    `Expected DefinedTerm span, got: ${JSON.stringify(result.spans)}`
                );
            } catch (err) {
                runner.logFail('test_defined_term', err.message);
            }

            // Test 4: Deixis - person pronouns
            // Note: serde-wasm-bindgen returns metadata as Map, not plain object
            try {
                runner.logInfo('test_deixis_person');
                const result = analyzeContract('I will meet you there.');
                const personDeixis = result.spans.filter(s =>
                    s.kind === 'DeicticReference' &&
                    s.metadata?.get?.('category') === 'Person'
                );
                runner.assert(
                    personDeixis.length >= 2,
                    'test_deixis_person',
                    `Expected at least 2 person deixis spans, got ${personDeixis.length}`
                );
            } catch (err) {
                runner.logFail('test_deixis_person', err.message);
            }

            // Test 5: Deixis - discourse markers
            try {
                runner.logInfo('test_deixis_discourse');
                const result = analyzeContract('However, the contract is valid. Therefore, we proceed.');
                const discourseDeixis = result.spans.filter(s =>
                    s.kind === 'DeicticReference' &&
                    s.metadata?.get?.('category') === 'Discourse'
                );
                runner.assert(
                    discourseDeixis.length >= 2,
                    'test_deixis_discourse',
                    `Expected at least 2 discourse markers, got ${discourseDeixis.length}`
                );
            } catch (err) {
                runner.logFail('test_deixis_discourse', err.message);
            }

            // Test 6: Deixis - metadata structure
            try {
                runner.logInfo('test_deixis_metadata');
                const result = analyzeContract('I am here now.');
                const deixis = result.spans.filter(s => s.kind === 'DeicticReference');
                const hasValidMetadata = deixis.length > 0 && deixis.every(s =>
                    s.metadata?.get?.('category') &&
                    s.metadata?.get?.('subcategory') &&
                    s.metadata?.get?.('surface_text') &&
                    typeof s.metadata?.get?.('confidence') === 'number'
                );
                runner.assert(
                    hasValidMetadata,
                    'test_deixis_metadata',
                    `Expected valid metadata on all deixis spans`
                );
            } catch (err) {
                runner.logFail('test_deixis_metadata', err.message);
            }

            // Test 7: Deixis filter toggle
            try {
                runner.logInfo('test_deixis_filter');
                const result = analyzeContract('I will be there tomorrow.');
                const allSpans = result.spans;
                const filteredSpans = allSpans.filter(s => s.kind !== 'DeicticReference');
                const deixisCount = allSpans.filter(s => s.kind === 'DeicticReference').length;
                runner.assert(
                    deixisCount > 0 && filteredSpans.length < allSpans.length,
                    'test_deixis_filter',
                    `Expected deixis spans to be filterable (${deixisCount} deixis spans found)`
                );
            } catch (err) {
                runner.logFail('test_deixis_filter', err.message);
            }

            runner.logInfo('');
            logEl.innerHTML = runner.getOutput();
        }

        // Event listeners
        document.getElementById('analyze-btn').addEventListener('click', handleAnalyze);
        document.getElementById('clear-btn').addEventListener('click', handleClear);
        document.getElementById('run-tests-btn').addEventListener('click', runTests);

        // Keyboard shortcut: Ctrl/Cmd + Enter to analyze
        document.getElementById('contract-input').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                handleAnalyze();
            }
        });

        // Try to load WASM on page load
        loadWasm();
    </script>

    <div style="margin-top: 2rem; text-align: center; font-size: 13px; color: #999;">
        <a href="contract-viewer-v2.html" style="color: #666;">Try the new visual viewer (v2)</a>
    </div>
</body>
</html>
