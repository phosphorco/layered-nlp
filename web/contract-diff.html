<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Contract Diff</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            background: #fafafa;
            color: #333;
            line-height: 1.5;
        }
        h1 {
            margin-bottom: 0.5rem;
            color: #1a1a1a;
        }
        .subtitle {
            color: #666;
            margin-bottom: 2rem;
        }

        /* Two-column input layout */
        .input-section {
            margin-bottom: 2rem;
        }
        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        .input-pane {
            display: flex;
            flex-direction: column;
        }
        .input-pane label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #374151;
        }
        .char-counter {
            font-size: 12px;
            color: #666;
            margin-top: 0.25rem;
            text-align: right;
        }
        .char-counter.over-limit {
            color: #dc2626;
            font-weight: 600;
        }
        textarea {
            width: 100%;
            height: 250px;
            padding: 1rem;
            font-family: ui-monospace, "Cascadia Code", "Source Code Pro", Menlo, Consolas, monospace;
            font-size: 13px;
            border: 1px solid #ddd;
            border-radius: 6px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #0969da;
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
        }

        /* Buttons */
        .button-row {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        button {
            padding: 0.6rem 1.2rem;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        button.primary {
            background: #0969da;
            color: white;
        }
        button.primary:hover {
            background: #0860c7;
        }
        button.secondary {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
        }
        button.secondary:hover {
            background: #e5e7eb;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Loading indicator */
        .loading {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: #666;
            font-size: 14px;
        }
        .loading.active {
            display: flex;
        }
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #ddd;
            border-top-color: #0969da;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results section with sidebar */
        .results-section {
            margin-top: 2rem;
        }
        .results-layout {
            display: grid;
            grid-template-columns: 220px 1fr;
            gap: 1.5rem;
        }

        /* Section outline sidebar */
        .section-sidebar {
            position: sticky;
            top: 1rem;
            max-height: calc(100vh - 2rem);
            overflow-y: auto;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 0.75rem 0;
        }
        .sidebar-header {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #6b7280;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 0.5rem;
        }
        .sidebar-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 1rem;
            font-size: 13px;
            color: #374151;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: background 0.1s, border-color 0.1s;
        }
        .sidebar-item:hover {
            background: #f9fafb;
        }
        .sidebar-item.active {
            background: #eff6ff;
            border-left-color: #3b82f6;
            font-weight: 500;
        }
        .sidebar-item.filtered-out {
            opacity: 0.4;
            pointer-events: none;
        }

        /* Filter controls in sidebar */
        .sidebar-filters {
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .filter-group {
            margin-bottom: 0.5rem;
        }
        .filter-group-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #9ca3af;
            margin-bottom: 0.25rem;
        }
        .filter-option {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.2rem 0;
            font-size: 12px;
            cursor: pointer;
        }
        .filter-option input[type="checkbox"] {
            margin: 0;
        }
        .filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .filter-dot.critical { background: #dc2626; }
        .filter-dot.high { background: #f97316; }
        .filter-dot.medium { background: #eab308; }
        .filter-dot.low { background: #22c55e; }
        .filter-dot.unchanged { background: #d1d5db; }
        .risk-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .risk-dot.critical { background: #dc2626; }
        .risk-dot.high { background: #f97316; }
        .risk-dot.medium { background: #eab308; }
        .risk-dot.low { background: #22c55e; }
        .risk-dot.unchanged { background: #d1d5db; }
        .risk-dot.inserted { background: #3b82f6; }
        .risk-dot.deleted { background: #ef4444; }
        .sidebar-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Main content area */
        .main-content {
            min-width: 0; /* Prevent grid blowout */
        }
        .panel {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        .panel h3 {
            margin: 0 0 1rem 0;
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Summary stats */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
        }
        .summary-stat {
            text-align: center;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 6px;
        }
        .summary-stat .value {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
        }
        .summary-stat .label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        /* Alignment summary */
        .alignment-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .alignment-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
        }
        .alignment-badge.exact-match { background: #dcfce7; color: #166534; }
        .alignment-badge.modified { background: #fef3c7; color: #92400e; }
        .alignment-badge.inserted { background: #dbeafe; color: #1e40af; }
        .alignment-badge.deleted { background: #fee2e2; color: #991b1b; }
        .alignment-badge.renumbered { background: #f3e8ff; color: #7c3aed; }
        .alignment-badge.other { background: #f3f4f6; color: #374151; }

        /* Changes list */
        .changes-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .change-item {
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 6px;
            border-left: 4px solid #ddd;
        }
        .change-item.risk-critical { border-left-color: #dc2626; }
        .change-item.risk-high { border-left-color: #f97316; }
        .change-item.risk-medium { border-left-color: #eab308; }
        .change-item.risk-low { border-left-color: #22c55e; }
        .change-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .change-type {
            font-weight: 600;
            color: #374151;
        }
        .risk-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .risk-badge.critical { background: #fee2e2; color: #dc2626; }
        .risk-badge.high { background: #ffedd5; color: #ea580c; }
        .risk-badge.medium { background: #fef9c3; color: #ca8a04; }
        .risk-badge.low { background: #dcfce7; color: #16a34a; }
        .change-explanation {
            font-size: 14px;
            color: #4b5563;
        }

        /* Warnings panel */
        .warnings-panel {
            background: #fffbeb;
            border-color: #fcd34d;
        }
        .warnings-panel h3 {
            color: #92400e;
        }
        .warning-item {
            padding: 0.5rem;
            background: #fef3c7;
            border-radius: 4px;
            font-size: 14px;
            color: #92400e;
            margin-bottom: 0.5rem;
        }
        .warning-item:last-child {
            margin-bottom: 0;
        }

        /* Error message */
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
        }
        .error-code {
            font-family: ui-monospace, monospace;
            font-size: 12px;
            background: #fee2e2;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            margin-right: 0.5rem;
        }

        /* Empty state */
        .empty-state {
            color: #666;
            font-style: italic;
            padding: 2rem;
            text-align: center;
        }

        /* Hidden by default */
        .hidden {
            display: none !important;
        }

        /* Section Comparison View */
        .comparison-view {
            margin-top: 1.5rem;
        }
        .comparison-header {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 0.5rem;
            position: sticky;
            top: 0;
            background: #fafafa;
            padding: 0.5rem 0;
            z-index: 10;
            border-bottom: 2px solid #e5e7eb;
        }
        .comparison-header-cell {
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #666;
            padding: 0.5rem;
        }
        .comparison-rows {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Section row - the container for a pair */
        .section-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            border-radius: 6px;
            overflow: hidden;
        }
        .section-row.unified {
            grid-template-columns: 1fr;
        }

        /* Section cell - left or right side */
        .section-cell {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            overflow: hidden;
        }
        .section-cell.empty {
            background: #f9fafb;
            border: 1px dashed #d1d5db;
            min-height: 60px;
        }

        /* Section header inside cell */
        .section-cell-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
        }
        .section-title {
            font-weight: 600;
            font-size: 13px;
            color: #374151;
        }
        .alignment-type-badge {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }

        /* Section content - readable font for contract text */
        .section-content {
            padding: 0.75rem;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.7;
            white-space: pre-wrap;
            word-break: break-word;
            color: #374151;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Alignment type styling */
        .section-row.exact-match .section-cell {
            border-color: #86efac;
            background: #f0fdf4;
        }
        .section-row.exact-match .section-cell-header {
            background: #dcfce7;
        }
        .section-row.exact-match .alignment-type-badge {
            background: #22c55e;
            color: white;
        }

        .section-row.modified .section-cell {
            border-color: #fcd34d;
        }
        .section-row.modified .section-cell-header {
            background: #fef3c7;
        }
        .section-row.modified .alignment-type-badge {
            background: #eab308;
            color: white;
        }

        .section-row.inserted .section-cell:not(.empty) {
            border-color: #93c5fd;
        }
        .section-row.inserted .section-cell-header {
            background: #dbeafe;
        }
        .section-row.inserted .alignment-type-badge {
            background: #3b82f6;
            color: white;
        }

        .section-row.deleted .section-cell:not(.empty) {
            border-color: #fca5a5;
        }
        .section-row.deleted .section-cell-header {
            background: #fee2e2;
        }
        .section-row.deleted .alignment-type-badge {
            background: #dc2626;
            color: white;
        }

        .section-row.renumbered .section-cell {
            border-color: #c4b5fd;
        }
        .section-row.renumbered .section-cell-header {
            background: #f3e8ff;
        }
        .section-row.renumbered .alignment-type-badge {
            background: #8b5cf6;
            color: white;
        }

        /* Collapsed state for ExactMatch */
        .section-row.collapsed .section-content {
            display: none;
        }
        .section-row.collapsed .section-cell {
            opacity: 0.7;
        }
        .section-row.collapsed .section-cell-header {
            cursor: pointer;
        }
        .section-row.collapsed .section-cell-header:hover {
            opacity: 0.9;
        }
        .expand-indicator {
            font-size: 10px;
            color: #666;
            margin-left: 0.5rem;
        }

        /* Collapsible input area */
        .input-section.collapsed .input-grid,
        .input-section.collapsed .button-row {
            display: none;
        }
        .input-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        .input-toggle h2 {
            margin: 0;
            font-size: 1rem;
            color: #374151;
        }
        .toggle-btn {
            background: none;
            border: 1px solid #d1d5db;
            padding: 0.3rem 0.6rem;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
        }
        .toggle-btn:hover {
            background: #f3f4f6;
        }

        /* Expand/Collapse All controls */
        .comparison-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .comparison-controls button {
            padding: 0.3rem 0.6rem;
            font-size: 12px;
        }

        /* Clickable summary stats */
        .summary-stat.clickable {
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .summary-stat.clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        /* Highlight effect for scrolled-to section */
        .section-row.highlight {
            animation: highlight-pulse 1.5s ease-out;
        }
        @keyframes highlight-pulse {
            0% { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5); }
            100% { box-shadow: none; }
        }

        /* Word-level diff highlighting */
        .diff-del {
            background: #fee2e2;
            color: #991b1b;
            text-decoration: line-through;
            padding: 0 2px;
            border-radius: 2px;
        }
        .diff-add {
            background: #dcfce7;
            color: #166534;
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Inline impact analysis panel */
        .impact-panel {
            background: #fffbeb;
            border-top: 1px solid #fcd34d;
            padding: 0.5rem 0.75rem;
            font-size: 13px;
        }
        .impact-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 0.25rem;
        }
        .impact-explanation {
            color: #78350f;
            margin-bottom: 0.25rem;
        }
        .party-impact {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 12px;
            margin-right: 0.75rem;
        }
        .party-favorable { color: #16a34a; }
        .party-unfavorable { color: #dc2626; }
        .party-neutral { color: #6b7280; }

        /* Hide unchanged toggle */
        .view-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.5rem 0.75rem;
            background: #f9fafb;
            border-radius: 6px;
        }
        .view-controls label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 13px;
            cursor: pointer;
        }
        .section-row.hidden-unchanged {
            display: none !important;
        }

        /* Keyboard navigation focus ring */
        .section-row.keyboard-focus {
            outline: 3px solid #3b82f6;
            outline-offset: 2px;
        }
    </style>
    <!-- diff-match-patch library for word-level diffs (with fallback) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>
    <script>
        // Fallback if CDN fails - create a no-op implementation
        if (typeof diff_match_patch === 'undefined') {
            console.warn('diff-match-patch CDN failed to load. Word-level diff disabled.');
            window.diff_match_patch = function() {
                this.diff_main = function(a, b) { return [[0, b]]; };
                this.diff_cleanupSemantic = function() {};
            };
        }
    </script>
</head>
<body>
    <h1>Semantic Contract Diff</h1>
    <p class="subtitle">Compare contract versions and identify legally significant changes</p>

    <div class="input-section" id="input-section">
        <div class="input-toggle">
            <h2>Contract Inputs</h2>
            <button class="toggle-btn" id="input-toggle-btn">Hide Inputs</button>
        </div>
        <div class="input-grid">
            <div class="input-pane">
                <label for="original-input">Original Contract</label>
                <textarea id="original-input" placeholder="Paste original contract text here..."></textarea>
                <div class="char-counter" id="original-counter">0 / 50,000</div>
            </div>
            <div class="input-pane">
                <label for="revised-input">Revised Contract</label>
                <textarea id="revised-input" placeholder="Paste revised contract text here..."></textarea>
                <div class="char-counter" id="revised-counter">0 / 50,000</div>
            </div>
        </div>
        <div class="button-row">
            <button id="compare-btn" class="primary" disabled>Compare</button>
            <button id="sample-btn" class="secondary">Load Sample NDA</button>
            <button id="clear-btn" class="secondary">Clear</button>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <span>Analyzing contracts...</span>
            </div>
        </div>
    </div>

    <div id="error-container"></div>

    <div id="results-section" class="results-section hidden">
        <!-- Summary panels (full width, above the grid) -->
        <div class="panel" id="summary-panel">
            <h3>Diff Summary</h3>
            <div class="summary-grid" id="summary-stats">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="panel" id="alignment-panel">
            <h3>Section Alignments</h3>
            <div class="alignment-badges" id="alignment-badges">
                <!-- Populated by JS -->
            </div>
        </div>

        <div class="panel warnings-panel hidden" id="warnings-panel">
            <h3>Alignment Warnings</h3>
            <div id="warnings-list">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- Grid layout: Sidebar + Main Content -->
        <div class="results-layout">
            <!-- Section Outline Sidebar -->
            <aside class="section-sidebar" id="section-sidebar">
                <div class="sidebar-header">Section Outline</div>
                <div class="sidebar-filters" id="sidebar-filters">
                    <div class="filter-group">
                        <div class="filter-group-label">Filter by Risk</div>
                        <label class="filter-option">
                            <input type="checkbox" id="filter-critical" checked>
                            <span class="filter-dot critical"></span>
                            Critical
                        </label>
                        <label class="filter-option">
                            <input type="checkbox" id="filter-high" checked>
                            <span class="filter-dot high"></span>
                            High
                        </label>
                        <label class="filter-option">
                            <input type="checkbox" id="filter-medium" checked>
                            <span class="filter-dot medium"></span>
                            Medium
                        </label>
                        <label class="filter-option">
                            <input type="checkbox" id="filter-low" checked>
                            <span class="filter-dot low"></span>
                            Low
                        </label>
                        <label class="filter-option">
                            <input type="checkbox" id="filter-unchanged" checked>
                            <span class="filter-dot unchanged"></span>
                            Unchanged
                        </label>
                    </div>
                </div>
                <div id="sidebar-items">
                    <!-- Populated by JS -->
                </div>
            </aside>

            <!-- Main Content Area -->
            <div class="main-content">
                <!-- Semantic Changes -->
                <div class="panel" id="changes-panel">
                    <h3>Semantic Changes</h3>
                    <div class="changes-list" id="changes-list">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Section Comparison View -->
                <div class="panel" id="comparison-panel">
                    <h3>Section Comparison</h3>
                    <div class="view-controls">
                        <label>
                            <input type="checkbox" id="hide-unchanged-toggle">
                            Hide Unchanged Sections
                        </label>
                        <button class="secondary" id="expand-all-btn">Expand All Unchanged</button>
                        <button class="secondary" id="collapse-all-btn">Collapse All Unchanged</button>
                    </div>
                    <div class="comparison-view">
                        <div class="comparison-header">
                            <div class="comparison-header-cell">Original</div>
                            <div class="comparison-header-cell">Revised</div>
                        </div>
                        <div class="comparison-rows" id="comparison-rows">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        const MAX_INPUT_SIZE = 50000;
        let wasmModule = null;
        let currentResult = null; // Store result for filtering/navigation

        // DOM elements
        const originalInput = document.getElementById('original-input');
        const revisedInput = document.getElementById('revised-input');
        const originalCounter = document.getElementById('original-counter');
        const revisedCounter = document.getElementById('revised-counter');
        const compareBtn = document.getElementById('compare-btn');
        const sampleBtn = document.getElementById('sample-btn');
        const clearBtn = document.getElementById('clear-btn');
        const loading = document.getElementById('loading');
        const errorContainer = document.getElementById('error-container');
        const resultsSection = document.getElementById('results-section');
        const inputSection = document.getElementById('input-section');
        const inputToggleBtn = document.getElementById('input-toggle-btn');
        const expandAllBtn = document.getElementById('expand-all-btn');
        const collapseAllBtn = document.getElementById('collapse-all-btn');
        const hideUnchangedToggle = document.getElementById('hide-unchanged-toggle');
        const sidebarItems = document.getElementById('sidebar-items');

        // Filter checkboxes
        const filterCritical = document.getElementById('filter-critical');
        const filterHigh = document.getElementById('filter-high');
        const filterMedium = document.getElementById('filter-medium');
        const filterLow = document.getElementById('filter-low');
        const filterUnchanged = document.getElementById('filter-unchanged');

        // Initialize diff-match-patch
        const dmp = new diff_match_patch();

        // Sample contracts from spec
        const SAMPLE_ORIGINAL = `ARTICLE I: DEFINITIONS

Section 1.1 "Confidential Information" means any non-public information
disclosed by either party to the other.

Section 1.2 "Receiving Party" means the party receiving Confidential Information.

ARTICLE II: OBLIGATIONS

Section 2.1 The Receiving Party shall protect all Confidential Information
using reasonable care.

Section 2.2 The Receiving Party shall not disclose Confidential Information
to any third party without prior written consent.

ARTICLE III: TERM

Section 3.1 This Agreement shall remain in effect for two (2) years from
the Effective Date.`;

        const SAMPLE_REVISED = `ARTICLE I: DEFINITIONS

Section 1.1 "Confidential Information" means any non-public technical
information disclosed by either party to the other.

Section 1.2 "Receiving Party" means the party receiving Confidential Information.

ARTICLE II: OBLIGATIONS

Section 2.1 The Receiving Party may protect all Confidential Information
using reasonable care.

Section 2.2 The Receiving Party shall not disclose Confidential Information
to any third party without prior written consent.

Section 2.3 The Receiving Party shall return all materials within 30 days
of termination.

ARTICLE III: TERM

Section 3.1 This Agreement shall remain in effect for three (3) years from
the Effective Date.`;

        // Load WASM module
        async function loadWasm() {
            try {
                const module = await import('./pkg/layered_nlp_demo_wasm.js');
                await module.default();
                wasmModule = module;
                console.log('WASM module loaded successfully');
                compareBtn.disabled = false;
                return true;
            } catch (err) {
                console.error('Failed to load WASM:', err);
                showError('wasm_load_failed', `Failed to load WASM module: ${err.message}. Make sure the WASM files are in ./pkg/`);
                return false;
            }
        }

        // Update character counter
        function updateCounter(input, counter) {
            const len = input.value.length;
            counter.textContent = `${len.toLocaleString()} / 50,000`;
            if (len > MAX_INPUT_SIZE) {
                counter.classList.add('over-limit');
            } else {
                counter.classList.remove('over-limit');
            }
        }

        // Show error message
        function showError(code, message, details = null) {
            let html = `<div class="error-message">`;
            if (code) {
                html += `<span class="error-code">${code}</span>`;
            }
            html += message;
            if (details) {
                html += `<pre style="margin-top: 0.5rem; font-size: 12px;">${JSON.stringify(details, null, 2)}</pre>`;
            }
            html += `</div>`;
            errorContainer.innerHTML = html;
        }

        // Clear error
        function clearError() {
            errorContainer.innerHTML = '';
        }

        // Format change type for display
        function formatChangeType(changeType) {
            if (typeof changeType === 'string') {
                return changeType.replace(/([A-Z])/g, ' $1').trim();
            }
            // Handle object form (e.g., { ObligationModal: {...} })
            const key = Object.keys(changeType)[0];
            return key.replace(/([A-Z])/g, ' $1').trim();
        }

        // Render results
        function renderResults(result) {
            currentResult = result; // Store for filtering/navigation
            resultsSection.classList.remove('hidden');

            // Collapse input area after showing results
            inputSection.classList.add('collapsed');
            inputToggleBtn.textContent = 'Show Inputs';

            // Access nested diff structure
            const diff = result.diff;
            const summary = diff.summary;

            // Summary stats (clickable to scroll to sections)
            const summaryStats = document.getElementById('summary-stats');
            summaryStats.innerHTML = `
                <div class="summary-stat">
                    <div class="value">${summary.total_changes}</div>
                    <div class="label">Total Changes</div>
                </div>
                <div class="summary-stat clickable" onclick="scrollToRisk('critical')" title="Click to scroll to critical changes">
                    <div class="value" style="color: #dc2626;">${summary.critical_changes}</div>
                    <div class="label">Critical</div>
                </div>
                <div class="summary-stat clickable" onclick="scrollToRisk('high')" title="Click to scroll to high-risk changes">
                    <div class="value" style="color: #f97316;">${summary.high_risk_changes}</div>
                    <div class="label">High</div>
                </div>
                <div class="summary-stat clickable" onclick="scrollToRisk('medium')" title="Click to scroll to medium-risk changes">
                    <div class="value" style="color: #eab308;">${summary.medium_risk_changes}</div>
                    <div class="label">Medium</div>
                </div>
                <div class="summary-stat clickable" onclick="scrollToRisk('low')" title="Click to scroll to low-risk changes">
                    <div class="value" style="color: #22c55e;">${summary.low_risk_changes}</div>
                    <div class="label">Low</div>
                </div>
            `;

            // Alignment badges - recalculate with corrected labels
            const correctedCounts = recalculateAlignmentCounts(result.aligned_pairs || []);
            const alignmentBadges = document.getElementById('alignment-badges');
            const badges = [];
            if (correctedCounts.unchanged > 0) badges.push(`<span class="alignment-badge exact-match">Unchanged: ${correctedCounts.unchanged}</span>`);
            if (correctedCounts.modified > 0) badges.push(`<span class="alignment-badge modified">Modified: ${correctedCounts.modified}</span>`);
            if (correctedCounts.inserted > 0) badges.push(`<span class="alignment-badge inserted">Added: ${correctedCounts.inserted}</span>`);
            if (correctedCounts.deleted > 0) badges.push(`<span class="alignment-badge deleted">Removed: ${correctedCounts.deleted}</span>`);
            if (correctedCounts.renumbered > 0) badges.push(`<span class="alignment-badge renumbered">Renumbered: ${correctedCounts.renumbered}</span>`);
            alignmentBadges.innerHTML = badges.length > 0 ? badges.join('') : '<span class="empty-state">No section alignments</span>';

            // Warnings panel
            const warningsPanel = document.getElementById('warnings-panel');
            const warningsList = document.getElementById('warnings-list');
            if (diff.warnings && diff.warnings.length > 0) {
                warningsPanel.classList.remove('hidden');
                warningsList.innerHTML = diff.warnings.map(w =>
                    `<div class="warning-item">${w}</div>`
                ).join('');
            } else {
                warningsPanel.classList.add('hidden');
            }

            // Changes list
            const changesList = document.getElementById('changes-list');
            if (diff.changes && diff.changes.length > 0) {
                changesList.innerHTML = diff.changes.map(change => {
                    const riskClass = `risk-${change.risk_level.toLowerCase()}`;
                    const changeTypeName = formatChangeType(change.change_type);
                    return `
                        <div class="change-item ${riskClass}">
                            <div class="change-header">
                                <span class="change-type">${changeTypeName}</span>
                                <span class="risk-badge ${change.risk_level.toLowerCase()}">${change.risk_level}</span>
                            </div>
                            <div class="change-explanation">${change.explanation}</div>
                        </div>
                    `;
                }).join('');
            } else {
                changesList.innerHTML = '<div class="empty-state">No semantic changes detected</div>';
            }

            // Section comparison view
            renderComparisonView(result.aligned_pairs || [], diff.changes || []);
        }

        // Convert alignment type to CSS class
        function alignmentTypeToClass(type) {
            const typeStr = typeof type === 'string' ? type : Object.keys(type)[0];
            return typeStr.toLowerCase().replace(/([A-Z])/g, '-$1').replace(/^-/, '');
        }

        // Get display label for alignment type
        function alignmentTypeLabel(type) {
            const typeStr = typeof type === 'string' ? type : Object.keys(type)[0];
            return typeStr.replace(/([A-Z])/g, ' $1').trim();
        }

        // Get section title for display
        function getSectionTitle(sections) {
            if (!sections || sections.length === 0) return 'Unknown Section';
            const first = sections[0];
            if (first.title) return first.title;
            return first.canonical_id || 'Section';
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Compute word-level diff and render as HTML with highlighting
        function renderWordDiff(original, revised) {
            if (!original && !revised) return '';
            if (!original) {
                // All added
                return `<span class="diff-add">${escapeHtml(revised)}</span>`;
            }
            if (!revised) {
                // All deleted
                return `<span class="diff-del">${escapeHtml(original)}</span>`;
            }

            // Compute diff
            const diffs = dmp.diff_main(original, revised);
            dmp.diff_cleanupSemantic(diffs);

            // Render with highlighting
            let html = '';
            for (const [op, text] of diffs) {
                const escaped = escapeHtml(text);
                if (op === -1) {
                    html += `<span class="diff-del">${escaped}</span>`;
                } else if (op === 1) {
                    html += `<span class="diff-add">${escaped}</span>`;
                } else {
                    html += escaped;
                }
            }
            return html;
        }

        // Check if two texts are 100% identical
        function textsAreIdentical(original, revised) {
            return original === revised;
        }

        // Determine the true alignment type based on text comparison
        function getTrueAlignmentType(pair) {
            // If backend says ExactMatch, verify the texts are actually identical
            if (pair.alignment_type === 'ExactMatch') {
                const origText = (pair.original_texts || []).join('\n');
                const revText = (pair.revised_texts || []).join('\n');
                if (!textsAreIdentical(origText, revText)) {
                    return 'Modified'; // Override to Modified if texts differ
                }
            }
            return pair.alignment_type;
        }

        // Recalculate alignment counts using corrected labels
        function recalculateAlignmentCounts(alignedPairs) {
            const counts = {
                unchanged: 0,
                modified: 0,
                inserted: 0,
                deleted: 0,
                renumbered: 0
            };

            for (const pair of alignedPairs) {
                const trueType = getTrueAlignmentType(pair);
                const typeClass = alignmentTypeToClass(trueType);

                if (typeClass === 'exact-match') {
                    counts.unchanged++;
                } else if (typeClass === 'modified') {
                    counts.modified++;
                } else if (typeClass === 'inserted') {
                    counts.inserted++;
                } else if (typeClass === 'deleted') {
                    counts.deleted++;
                } else if (typeClass === 'renumbered') {
                    counts.renumbered++;
                }
            }

            return counts;
        }

        // Create impact analysis panel HTML
        function createImpactPanel(changes) {
            if (!changes || changes.length === 0) return '';

            const panelsHtml = changes.map(change => {
                const typeName = formatChangeType(change.change_type);
                const riskClass = change.risk_level.toLowerCase();

                // Format party impacts
                let partyHtml = '';
                if (change.party_impacts && change.party_impacts.length > 0) {
                    partyHtml = change.party_impacts.map(pi => {
                        const impact = pi.impact || 'Neutral';
                        const impactClass = impact === 'Favorable' ? 'party-favorable' :
                                            impact === 'Unfavorable' ? 'party-unfavorable' : 'party-neutral';
                        const arrow = impact === 'Favorable' ? '↑' :
                                      impact === 'Unfavorable' ? '↓' : '→';
                        return `<span class="party-impact ${impactClass}">${arrow} ${escapeHtml(pi.party || 'Unknown')}: ${impact}</span>`;
                    }).join('');
                }

                return `
                    <div class="impact-panel">
                        <div class="impact-header">
                            <span>⚠️ ${typeName}</span>
                            <span class="risk-indicator ${riskClass}">${change.risk_level}</span>
                        </div>
                        <div class="impact-explanation">${escapeHtml(change.explanation)}</div>
                        ${partyHtml ? `<div class="party-impacts">${partyHtml}</div>` : ''}
                    </div>
                `;
            }).join('');

            return panelsHtml;
        }

        // Find changes that affect a section (by matching section IDs in explanations)
        function findChangesForSection(sectionIds, changes) {
            if (!sectionIds || sectionIds.length === 0 || !changes) return [];
            // Match changes by checking if explanation contains any section ID
            // This works because structural changes include "Section {id}" in explanations
            return changes.filter(c => {
                const explanation = c.explanation || '';
                return sectionIds.some(id => explanation.includes(id));
            });
        }

        // Get the highest risk level for a section based on its changes
        function getRiskLevelForSection(sectionChanges, alignmentType) {
            const typeClass = alignmentTypeToClass(alignmentType);

            // If there are semantic changes, use the highest risk level
            if (sectionChanges && sectionChanges.length > 0) {
                const riskOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
                let maxRisk = 'low';
                for (const change of sectionChanges) {
                    const level = change.risk_level.toLowerCase();
                    if (riskOrder[level] > riskOrder[maxRisk]) {
                        maxRisk = level;
                    }
                }
                return maxRisk;
            }

            // No semantic changes - use alignment type
            if (typeClass === 'exact-match') return 'unchanged';
            if (typeClass === 'inserted') return 'inserted';
            if (typeClass === 'deleted') return 'deleted';
            return 'medium'; // Modified without detected changes
        }

        // Populate the section outline sidebar
        function populateSidebar(alignedPairs, changes) {
            if (!alignedPairs || alignedPairs.length === 0) {
                sidebarItems.innerHTML = '<div class="empty-state" style="padding: 1rem; font-size: 12px;">No sections</div>';
                return;
            }

            let html = '';
            for (let i = 0; i < alignedPairs.length; i++) {
                const pair = alignedPairs[i];
                const trueType = getTrueAlignmentType(pair);
                const title = getSectionTitle(pair.original.length > 0 ? pair.original : pair.revised);
                const sectionChanges = findChangesForSection(pair.section_ids || [], changes);
                const riskLevel = getRiskLevelForSection(sectionChanges, trueType);
                const rowId = `section-row-${i}`;

                html += `
                    <div class="sidebar-item" data-target="${rowId}" data-index="${i}">
                        <span class="risk-dot ${riskLevel}"></span>
                        <span class="sidebar-title" title="${escapeHtml(title)}">${escapeHtml(title)}</span>
                    </div>
                `;
            }

            sidebarItems.innerHTML = html;

            // Add click handlers for sidebar items
            sidebarItems.querySelectorAll('.sidebar-item').forEach(item => {
                item.addEventListener('click', () => {
                    const targetId = item.dataset.target;
                    const target = document.getElementById(targetId);
                    if (target) {
                        // Remove previous highlights
                        document.querySelectorAll('.section-row.highlight').forEach(el => {
                            el.classList.remove('highlight');
                        });
                        // Expand if collapsed
                        target.classList.remove('collapsed');
                        // Scroll and highlight
                        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        target.classList.add('highlight');
                        // Update active state in sidebar
                        sidebarItems.querySelectorAll('.sidebar-item').forEach(s => s.classList.remove('active'));
                        item.classList.add('active');
                    }
                });
            });
        }

        // Setup Intersection Observer for scroll-sync
        let scrollSyncObserver = null;
        function setupScrollSync() {
            // Disconnect previous observer if exists
            if (scrollSyncObserver) {
                scrollSyncObserver.disconnect();
            }

            const sectionRows = document.querySelectorAll('.section-row');
            if (sectionRows.length === 0) return;

            scrollSyncObserver = new IntersectionObserver((entries) => {
                // Find the most visible section
                let mostVisible = null;
                let maxRatio = 0;

                for (const entry of entries) {
                    if (entry.isIntersecting && entry.intersectionRatio > maxRatio) {
                        maxRatio = entry.intersectionRatio;
                        mostVisible = entry.target;
                    }
                }

                if (mostVisible) {
                    const index = mostVisible.id.replace('section-row-', '');
                    // Update sidebar active state
                    sidebarItems.querySelectorAll('.sidebar-item').forEach(item => {
                        if (item.dataset.index === index) {
                            item.classList.add('active');
                            // Scroll sidebar to keep active item visible
                            item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                        } else {
                            item.classList.remove('active');
                        }
                    });
                }
            }, {
                root: null, // viewport
                rootMargin: '-10% 0px -70% 0px', // Trigger when section enters top 30% of viewport
                threshold: [0, 0.25, 0.5, 0.75, 1]
            });

            // Observe all section rows
            sectionRows.forEach(row => scrollSyncObserver.observe(row));
        }

        // Keyboard navigation state
        let keyboardFocusIndex = -1;

        // Get all visible changed section indices (skip ExactMatch and hidden)
        function getVisibleChangedIndices() {
            const indices = [];
            document.querySelectorAll('.section-row').forEach((row, i) => {
                if (!row.classList.contains('hidden-unchanged') &&
                    !row.classList.contains('exact-match')) {
                    indices.push(i);
                }
            });
            return indices;
        }

        // Navigate to section by index
        function navigateToSection(index) {
            // Remove previous focus
            document.querySelectorAll('.section-row.keyboard-focus').forEach(el => {
                el.classList.remove('keyboard-focus');
            });

            const row = document.getElementById(`section-row-${index}`);
            if (row) {
                // Expand if collapsed
                row.classList.remove('collapsed');
                // Add focus ring
                row.classList.add('keyboard-focus');
                // Scroll into view
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Update URL hash
                window.history.replaceState(null, '', `#section-${index}`);
                // Update sidebar active state
                sidebarItems.querySelectorAll('.sidebar-item').forEach(item => {
                    if (item.dataset.index === String(index)) {
                        item.classList.add('active');
                        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    } else {
                        item.classList.remove('active');
                    }
                });
            }
        }

        // Keyboard navigation handler
        function handleKeyboardNavigation(e) {
            // Only handle j/k when not in an input field
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                return;
            }

            const changedIndices = getVisibleChangedIndices();
            if (changedIndices.length === 0) return;

            if (e.key === 'j') {
                // Next changed section
                e.preventDefault();
                if (keyboardFocusIndex === -1) {
                    keyboardFocusIndex = changedIndices[0];
                } else {
                    const currentPos = changedIndices.indexOf(keyboardFocusIndex);
                    if (currentPos < changedIndices.length - 1) {
                        keyboardFocusIndex = changedIndices[currentPos + 1];
                    } else {
                        // Wrap to first
                        keyboardFocusIndex = changedIndices[0];
                    }
                }
                navigateToSection(keyboardFocusIndex);
            } else if (e.key === 'k') {
                // Previous changed section
                e.preventDefault();
                if (keyboardFocusIndex === -1) {
                    keyboardFocusIndex = changedIndices[changedIndices.length - 1];
                } else {
                    const currentPos = changedIndices.indexOf(keyboardFocusIndex);
                    if (currentPos > 0) {
                        keyboardFocusIndex = changedIndices[currentPos - 1];
                    } else {
                        // Wrap to last
                        keyboardFocusIndex = changedIndices[changedIndices.length - 1];
                    }
                }
                navigateToSection(keyboardFocusIndex);
            }
        }

        // Apply filters based on checkbox states
        function applyFilters() {
            const showCritical = filterCritical.checked;
            const showHigh = filterHigh.checked;
            const showMedium = filterMedium.checked;
            const showLow = filterLow.checked;
            const showUnchanged = filterUnchanged.checked;

            // Map risk levels to filter state
            const filterMap = {
                'critical': showCritical,
                'high': showHigh,
                'medium': showMedium,
                'low': showLow
            };

            // Filter section rows
            document.querySelectorAll('.section-row').forEach(row => {
                const risk = row.dataset.risk; // May be undefined
                const typeClass = row.classList.contains('exact-match') ? 'exact-match' :
                                  row.classList.contains('inserted') ? 'inserted' :
                                  row.classList.contains('deleted') ? 'deleted' : 'modified';

                // Determine if this row should be visible
                let shouldShow;
                if (typeClass === 'exact-match') {
                    // Unchanged sections controlled by unchanged filter
                    shouldShow = showUnchanged;
                } else if (typeClass === 'inserted' || typeClass === 'deleted') {
                    // Inserted/Deleted are always changes - show based on their risk level if set,
                    // otherwise always show (they're structural changes)
                    if (risk && filterMap[risk] !== undefined) {
                        shouldShow = filterMap[risk];
                    } else {
                        shouldShow = true; // Always show if no specific risk
                    }
                } else {
                    // Modified - use the risk level, default to showing if no risk
                    if (risk && filterMap[risk] !== undefined) {
                        shouldShow = filterMap[risk];
                    } else {
                        shouldShow = true; // Show modified without specific risk
                    }
                }

                if (shouldShow) {
                    row.classList.remove('hidden-unchanged');
                } else {
                    row.classList.add('hidden-unchanged');
                }
            });

            // Update sidebar items to match
            sidebarItems.querySelectorAll('.sidebar-item').forEach(item => {
                const index = item.dataset.index;
                const row = document.getElementById(`section-row-${index}`);
                if (row && row.classList.contains('hidden-unchanged')) {
                    item.classList.add('filtered-out');
                } else {
                    item.classList.remove('filtered-out');
                }
            });
        }

        // Render section comparison view
        function renderComparisonView(alignedPairs, changes) {
            const comparisonRows = document.getElementById('comparison-rows');

            if (!alignedPairs || alignedPairs.length === 0) {
                comparisonRows.innerHTML = '<div class="empty-state">No sections to compare</div>';
                return;
            }

            let html = '';
            let sectionIndex = 0;

            for (const pair of alignedPairs) {
                // Gate 3.4: Fix ExactMatch labeling - only 100% identical = ExactMatch
                const trueAlignmentType = getTrueAlignmentType(pair);
                const typeClass = alignmentTypeToClass(trueAlignmentType);
                const typeLabel = alignmentTypeLabel(trueAlignmentType);
                const isExactMatch = typeClass === 'exact-match';
                const isInserted = typeClass === 'inserted';
                const isDeleted = typeClass === 'deleted';

                // Find changes affecting this pair's sections
                const sectionChanges = findChangesForSection(
                    pair.section_ids || [],
                    changes
                );
                const rowId = `section-row-${sectionIndex}`;
                const riskAttr = sectionChanges.length > 0
                    ? `data-risk="${sectionChanges[0].risk_level.toLowerCase()}"`
                    : '';

                // Gate 3.5-3.6: Create impact panel with explanation and party_impacts
                const impactHtml = createImpactPanel(sectionChanges);

                // Determine row structure based on alignment type
                if (isExactMatch) {
                    // Unified row for TRUE ExactMatch (collapsed by default)
                    const title = getSectionTitle(pair.original.length > 0 ? pair.original : pair.revised);
                    const content = pair.original_texts.length > 0
                        ? pair.original_texts.join('\n\n')
                        : pair.revised_texts.join('\n\n');

                    html += `
                        <div class="section-row unified exact-match collapsed" id="${rowId}" ${riskAttr}>
                            <div class="section-cell">
                                <div class="section-cell-header" onclick="this.closest('.section-row').classList.toggle('collapsed')" style="cursor: pointer;">
                                    <span class="section-title">
                                        ${escapeHtml(title)}
                                        <span class="expand-indicator">(click to expand)</span>
                                    </span>
                                    <span class="alignment-type-badge">Unchanged</span>
                                </div>
                                <div class="section-content">${escapeHtml(content)}</div>
                            </div>
                        </div>
                    `;
                } else if (isInserted) {
                    // Right-only for Inserted - all text is "added"
                    const title = getSectionTitle(pair.revised);
                    const content = pair.revised_texts.join('\n\n');
                    const diffHtml = renderWordDiff('', content);
                    html += `
                        <div class="section-row inserted" id="${rowId}" ${riskAttr}>
                            <div class="section-cell empty"></div>
                            <div class="section-cell">
                                <div class="section-cell-header">
                                    <span class="section-title">${escapeHtml(title)}</span>
                                    <span class="alignment-type-badge">Added</span>
                                </div>
                                <div class="section-content">${diffHtml}</div>
                                ${impactHtml}
                            </div>
                        </div>
                    `;
                } else if (isDeleted) {
                    // Left-only for Deleted - all text is "removed"
                    const title = getSectionTitle(pair.original);
                    const content = pair.original_texts.join('\n\n');
                    const diffHtml = renderWordDiff(content, '');
                    html += `
                        <div class="section-row deleted" id="${rowId}" ${riskAttr}>
                            <div class="section-cell">
                                <div class="section-cell-header">
                                    <span class="section-title">${escapeHtml(title)}</span>
                                    <span class="alignment-type-badge">Removed</span>
                                </div>
                                <div class="section-content">${diffHtml}</div>
                                ${impactHtml}
                            </div>
                            <div class="section-cell empty"></div>
                        </div>
                    `;
                } else {
                    // Side-by-side for Modified, Renumbered, etc.
                    // Gate 3.2-3.3: Show word-level diff highlighting
                    const origTitle = getSectionTitle(pair.original);
                    const revTitle = getSectionTitle(pair.revised);
                    const origContent = pair.original_texts.join('\n\n');
                    const revContent = pair.revised_texts.join('\n\n');

                    // Compute unified diff view for the revised side
                    const diffHtml = renderWordDiff(origContent, revContent);

                    html += `
                        <div class="section-row ${typeClass}" id="${rowId}" ${riskAttr}>
                            <div class="section-cell">
                                <div class="section-cell-header">
                                    <span class="section-title">${escapeHtml(origTitle)}</span>
                                    <span class="alignment-type-badge" style="opacity: 0.5">Original</span>
                                </div>
                                <div class="section-content">${escapeHtml(origContent)}</div>
                            </div>
                            <div class="section-cell">
                                <div class="section-cell-header">
                                    <span class="section-title">${escapeHtml(revTitle)}</span>
                                    <span class="alignment-type-badge">${typeLabel}</span>
                                </div>
                                <div class="section-content">${diffHtml}</div>
                                ${impactHtml}
                            </div>
                        </div>
                    `;
                }
                sectionIndex++;
            }

            comparisonRows.innerHTML = html;

            // Reset filters to show all
            hideUnchangedToggle.checked = false;
            filterCritical.checked = true;
            filterHigh.checked = true;
            filterMedium.checked = true;
            filterLow.checked = true;
            filterUnchanged.checked = true;

            // Reset keyboard navigation
            keyboardFocusIndex = -1;

            // Populate sidebar and setup scroll-sync
            populateSidebar(alignedPairs, changes);
            setupScrollSync();
        }

        // Compare contracts
        async function compareContracts() {
            clearError();
            resultsSection.classList.add('hidden');
            loading.classList.add('active');
            compareBtn.disabled = true;

            try {
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));

                const original = originalInput.value;
                const revised = revisedInput.value;

                const result = wasmModule.compare_contracts(original, revised);

                // Check for error response
                if (result.error) {
                    showError(result.error.code, result.error.message, result.error.details);
                } else {
                    renderResults(result);
                }
            } catch (err) {
                console.error('Compare failed:', err);
                showError('internal_error', `Comparison failed: ${err.message}`);
            } finally {
                loading.classList.remove('active');
                compareBtn.disabled = false;
            }
        }

        // Scroll to first section with given risk level (exposed globally for onclick)
        window.scrollToRisk = function(riskLevel) {
            const selector = `.section-row[data-risk="${riskLevel}"]`;
            const target = document.querySelector(selector);
            if (target) {
                // Remove previous highlights
                document.querySelectorAll('.section-row.highlight').forEach(el => {
                    el.classList.remove('highlight');
                });
                // Expand if collapsed
                target.classList.remove('collapsed');
                // Scroll and highlight
                target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                target.classList.add('highlight');
            }
        }

        // Event listeners
        originalInput.addEventListener('input', () => updateCounter(originalInput, originalCounter));
        revisedInput.addEventListener('input', () => updateCounter(revisedInput, revisedCounter));

        compareBtn.addEventListener('click', compareContracts);

        sampleBtn.addEventListener('click', () => {
            originalInput.value = SAMPLE_ORIGINAL;
            revisedInput.value = SAMPLE_REVISED;
            updateCounter(originalInput, originalCounter);
            updateCounter(revisedInput, revisedCounter);
        });

        clearBtn.addEventListener('click', () => {
            originalInput.value = '';
            revisedInput.value = '';
            updateCounter(originalInput, originalCounter);
            updateCounter(revisedInput, revisedCounter);
            clearError();
            resultsSection.classList.add('hidden');
            currentResult = null;
            // Expand input area
            inputSection.classList.remove('collapsed');
            inputToggleBtn.textContent = 'Hide Inputs';
        });

        // Input toggle
        inputToggleBtn.addEventListener('click', () => {
            inputSection.classList.toggle('collapsed');
            inputToggleBtn.textContent = inputSection.classList.contains('collapsed')
                ? 'Show Inputs'
                : 'Hide Inputs';
        });

        // Expand/Collapse all unchanged sections
        expandAllBtn.addEventListener('click', () => {
            document.querySelectorAll('.section-row.exact-match.collapsed').forEach(row => {
                row.classList.remove('collapsed');
            });
        });

        collapseAllBtn.addEventListener('click', () => {
            document.querySelectorAll('.section-row.exact-match:not(.collapsed)').forEach(row => {
                row.classList.add('collapsed');
            });
        });

        // Gate 3.7: Hide Unchanged Sections toggle - syncs with filter checkbox
        hideUnchangedToggle.addEventListener('change', () => {
            filterUnchanged.checked = !hideUnchangedToggle.checked;
            applyFilters();
        });

        // Filter checkbox event listeners
        [filterCritical, filterHigh, filterMedium, filterLow, filterUnchanged].forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                applyFilters();
                // Sync hideUnchangedToggle with filterUnchanged
                hideUnchangedToggle.checked = !filterUnchanged.checked;
            });
        });

        // Keyboard navigation
        document.addEventListener('keydown', handleKeyboardNavigation);

        // Handle URL hash on page load
        function scrollToHashOnLoad() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#section-')) {
                const index = parseInt(hash.replace('#section-', ''), 10);
                if (!isNaN(index)) {
                    // Wait for DOM to be ready
                    setTimeout(() => {
                        const row = document.getElementById(`section-row-${index}`);
                        if (row) {
                            keyboardFocusIndex = index;
                            navigateToSection(index);
                        }
                    }, 100);
                }
            }
        }

        // Initialize
        loadWasm();
        scrollToHashOnLoad();
    </script>
</body>
</html>
